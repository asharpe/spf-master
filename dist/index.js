"use strict";Object.defineProperty(exports,"__esModule",{value:!0});var e=require("dns"),r=require("spf-parse"),s=require("ip-regex"),p=require("rambda");function o(e){var r=Object.create(null);return e&&Object.keys(e).forEach((function(s){if("default"!==s){var p=Object.getOwnPropertyDescriptor(e,s);Object.defineProperty(r,s,p.get?p:{enumerable:!0,get:function(){return e[s]}})}})),r.default=e,Object.freeze(r)}var t,i,a=o(e);exports.SpfType=void 0,(t=exports.SpfType||(exports.SpfType={})).include="include",t.version="version",t.all="all",t.mx="mx",t.ip4="ip4",t.ip6="ip6",t.a="a",function(e){e.UNKNWON="EUNKNWON",e.NOTFOUND="ENOTFOUND",e.IPS_NOT_MATCH="IPSMATCH",e.INC_NOT_MATCH="INCMATCH",e.DOM_NOT_MATCH="DOMMATCH"}(i||(i={}));var n=i;const l=p.curry(((e,r)=>r.includes(e))),u=(e,o={},t=!0)=>{let n={found:!1,ips:[],includes:[],domains:[],match:!1,lookups:0};const u=e=>(e=>s.v4().test(e)||s.v6().test(e))(e)?Promise.reject(new Error(`Domain ${e} is a raw ip !`)):new Promise(((s,p)=>{n.lookups+=1,a.resolveTxt(e,((e,o)=>{if(e)return p(e);s(o.reduce(((e,r)=>[...e,...r])).filter((e=>e.includes("v=spf1"))).map((e=>({record:e,detail:r(e||"")}))))}))})),c=async(e,r)=>{if((e=>{const r=p.pathOr([],["detail","mechanisms"],e);0!==p.length(r)&&(r.filter(p.or(p.propEq("type",exports.SpfType.ip4),p.propEq("type",exports.SpfType.ip6))).map(p.prop("value")).forEach((e=>{l(e,n.ips)||n.ips.push(e)})),r.filter(p.propEq("type",exports.SpfType.include)).map(p.prop("value")).forEach((e=>{n.lookups+=1,l(e,n.includes)||n.includes.push(e)})),r.filter(p.propEq("type",exports.SpfType.a)).map(p.prop("value")).forEach((e=>{n.lookups+=1,l(e,n.domains)||n.domains.push(e)})),n.match=[p.equals(n.includes,p.propOr([],"includes",o)),p.equals(n.ips,p.propOr([],"ips",o)),p.equals(n.domains,p.propOr([],"domains",o))].every(p.equals(!0))||n.match)})(e),n.match&&t)return Promise.resolve(e);if(r<0)return Promise.resolve(e);const s=p.pathOr([],["detail","mechanisms"],e).filter(p.propEq("type",exports.SpfType.include));if(0===p.length(s))return Promise.resolve(e);const i=await Promise.all(s.map((e=>e.value)).map((e=>u(e))));return e.includes=await Promise.all(p.flatten(i).map((e=>new Promise((async s=>s(await c(e,r-1))))))),Promise.resolve(e)};return u(e).then((e=>Promise.all(e.map((e=>p.path(["detail","valid"],e)?c(e,Math.max(0,p.defaultTo(10,o.maxDepth))):Promise.resolve(e)))).then((e=>{const r=p.compose(p.reject(p.either(p.isNil,p.isEmpty)),p.defaultTo([]));return Promise.resolve({records:e||[],lookups:n.lookups,found:{ips:r(n.ips),includes:r(n.includes),domains:r(n.domains)},isMatch:n.match,reason:""})})).catch((e=>Promise.reject({records:[],found:{ips:[],includes:[],domains:[]},isMatch:!1,reason:i.NOTFOUND})))))};exports.InspecterError=n,exports.SpfInspector=u,exports.default=u;
